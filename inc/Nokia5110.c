// Nokia5110.c
// Runs on MSP432
// Use eUSCI_A3 to send an 8-bit code to the Nokia5110 48x84
// pixel LCD to display text, images, or other information.
// Daniel Valvano
// July 11, 2019
// Font table, initialization, and other functions based
// off of Nokia_5110_Example from Spark Fun:
// 7-17-2011
// Spark Fun Electronics 2011
// Nathan Seidle
// http://dlnmh9ip6v2uc.cloudfront.net/datasheets/LCD/Monochrome/Nokia_5110_Example.pde
//
// Updated by Stan Baek
// June 11, 2022

/* This example accompanies the book
   "Embedded Systems: Introduction to Robotics,
   Jonathan W. Valvano, ISBN: 9781074544300, copyright (c) 2019
 For more information about my classes, my research, and my books, see
 http://users.ece.utexas.edu/~valvano/

Simplified BSD License (FreeBSD License)
Copyright (c) 2019, Jonathan Valvano, All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are
those of the authors and should not be interpreted as representing official
policies, either expressed or implied, of the FreeBSD Project.
*/

// Red SparkFun Nokia 5110 (LCD-10168)
// -----------------------------------
// Signal        (Nokia 5110) LaunchPad pin
// 3.3V          (VCC, pin 1) power
// Ground        (GND, pin 2) ground
// UCA3STE       (SCE, pin 3) connected to P9.4
// Reset         (RST, pin 4) connected to P9.3
// Data/Command  (D/C, pin 5) connected to P9.6
// UCA3SIMO      (DN,  pin 6) connected to P9.7
// UCA3CLK       (SCLK, pin 7) connected to P9.5
// back light    (LED, pin 8) not connected, consists of 4 3.3 V white LEDs which draw ~80mA total

// Blue Adafruit 338 Nokia 5110
// ---------------
// Signal        (Nokia 5110) LaunchPad pin
// Ground        (Gnd, pin 1) ground
// 3.3V          (Vcc, pin 2) power
// UCA3CLK       (Clk, pin 3) connected to P9.5
// UCA3SIMO      (Din, pin 4) connected to P9.7
// Data/Command  (D/C, pin 5) connected to P9.6
// UCA3STE       (CS,  pin 6) connected to P9.4
// Reset         (RST, pin 7) connected to P9.3
// back light    (LED, pin 8) not connected, consists of 4 white LEDs which draw ~80mA total

// Blue Nokia 5110
// ---------------
// Signal        (Nokia 5110) LaunchPad pin
// Reset         (RST, pin 1) connected to P9.3
// UCA3STE       (CE,  pin 2) connected to P9.4
// Data/Command  (DC,  pin 3) connected to P9.6
// UCA3SIMO      (Din, pin 4) connected to P9.7
// UCA3CLK       (Clk, pin 5) connected to P9.5
// 3.3V          (Vcc, pin 6) power
// back light    (BL,  pin 7) not connected, consists of 4 3.3 V white LEDs which draw ~80mA total
// Ground        (Gnd, pin 8) ground

#include <stdio.h>
#include <stdint.h>
#include "msp.h"
#include "SPIA3.h"

// *************************** Screen dimensions ***************************
#define SCREENW     84
#define SCREENH     48

// Maximum columns of the LCD, although the pixels are
// numbered from zero to (MAX-1).  Address may automatically
// be incremented after each transmission.
#define MAX_X       84  // Same as SCREENW

// Maximum rows of the LCD, although the pixels are
// numbered from zero to (MAX-1).  In the default horizontal
// addressing mode (V = 0), rows are clustered into groups of
// eight, which are all sent together with one 8-bit SSI data
// transmission.
#define MAX_Y       48  // Same as SCREENH

// The regular 8-bit access for P9OUT is 0x40004C82.
// For bit-banding of bit 6 of P9OUT, n=0x4C82 and b=6.
// 0x42000000 + 32*4C82 + 4*6 = 0x42099040+0x18 = 0x42099058
// For bit-banding of bit 3 of P9OUT, n=0x4C82 and b=3.
// 0x42000000 + 32*4C82 + 4*3 = 0x42099040+0x0C = 0x4209904C
#define DC          (*((volatile uint8_t *)0x42099058))   /* Port 9 Output, bit 6 is DC*/
#define RESET       (*((volatile uint8_t *)0x4209904C))   /* Port 9 Output, bit 3 is RESET*/


// This table contains the hex values that represent pixels
// for a font that is 5 pixels wide and 8 pixels high
static const uint8_t ASCII[][5] = {
   {0x00, 0x00, 0x00, 0x00, 0x00} // 20
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c '\'
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e ~
  // ,{0x78, 0x46, 0x41, 0x46, 0x78} // 7f DEL
  ,{0x0e, 0x05, 0x0e, 0x7c, 0x14} // 7f AF sign
};

const uint8_t af_logo[] ={
 0x42, 0x4D, 0xAE, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x38, 0x04, 0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x92, 0x92, 0x92, 0x00, 0x45, 0x45,
 0x45, 0x00, 0xCD, 0xCD, 0xCD, 0x00, 0x64, 0x64, 0x64, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0x2E, 0x2E, 0x2E, 0x00, 0xB1, 0xB1, 0xB1, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x59, 0x59, 0x59, 0x00, 0x7B, 0x7B,
 0x7B, 0x00, 0x18, 0x18, 0x18, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xBF, 0xBF, 0xBF, 0x00, 0x3B, 0x3B, 0x3B, 0x00, 0x9C, 0x9C, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x08, 0x88, 0x88, 0x80, 0x05, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x00, 0x88, 0x88, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x87, 0x00, 0x0F, 0x10, 0x00, 0x78, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x88, 0x88,
 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x00, 0xD8, 0x83, 0x00, 0x88, 0x88, 0x88, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x88, 0x88, 0x0B, 0x88, 0x88, 0x60, 0x88, 0x88, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x0D, 0x88, 0x88, 0x30, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x09, 0x88, 0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x44, 0x4A, 0x3E, 0x00, 0x00, 0xE3, 0xA4, 0x44, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x0E, 0x88, 0x88, 0x88, 0x30, 0x00, 0x00, 0x03, 0x88, 0x88, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x88, 0x88, 0x80,
 0x08, 0xD0, 0x0D, 0x80, 0x08, 0x88, 0x88, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x85, 0x00, 0x88, 0x80, 0x08, 0x88, 0xB0, 0x58, 0x88, 0x88,
 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x88, 0x88, 0x88, 0x60, 0x38, 0x88, 0x80, 0x08, 0x88, 0x83, 0x06, 0x88, 0x88, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x08, 0x88, 0x88, 0x80, 0x08, 0x88, 0x88, 0x8A, 0x48, 0x88, 0x88, 0x80, 0x08, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x88, 0x83, 0x06, 0x88, 0x88,
 0x88, 0xD0, 0x0D, 0x88, 0x88, 0x88, 0x60, 0xD8, 0x88, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x00,
 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x08, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x80, 0x08, 0x88, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x08, 0x8F, 0x04, 0x88, 0x88, 0x88, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x88, 0x88, 0x88, 0x40, 0x18, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x88, 0x88, 0x88, 0x80, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88,
 0x88, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x88, 0x88, 0x88, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x88, 0x88, 0x88, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x8C, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x06, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x00, 0x00, 0x00, 0x05,
 0x88, 0x8A, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xA8, 0x88, 0x50, 0x00, 0x00, 0x08, 0x88, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x88, 0x80, 0x00, 0x00, 0x58, 0x80, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x08, 0x80, 0x08, 0x85, 0x00, 0x00, 0x84, 0x07, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x70, 0x48, 0x00, 0x08, 0x00,
 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x80, 0x00, 0x98, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x89, 0x00, 0x00, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x08, 0x88, 0x88, 0x00, 0x00, 0x58, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00, 0x08,
 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x00, 0x00, 0x08, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF
};


// This is a helper function that sends 8-bit commands to the LCD.
// Inputs: command  8-bit function code to transmit
// Outputs: none
// Assumes: UCA3 and Port 9 have already been initialized and enabled
// The Data/Command pin must be valid when the eighth bit is
// sent.  The eUSCI module has no hardware FIFOs.
// 1) Wait for SPI to be idle (let previous frame finish)
// 2) Set DC for command (0)
// 3) Write command to TXBUF, starts SPI
// 4) Wait for SPI to be idle (after transmission complete)
static void commandwrite(uint8_t command) {

    // solution
    // Wait for SPI TX/RX to be ready
    SPIA3_Wait4TxRxReady();

    // DC = 0 for command
    DC = 0;

    // Send data using TXBUF
    SPIA3_WriteTxBuffer(command);

    // Wait for SPI TX/RX to be ready
    SPIA3_Wait4TxRxReady();

}


// This is a helper function that sends 8-bit data to the LCD.
// Inputs: data  8-bit data to transmit
// Outputs: none
// Assumes: UCA3 and Port 9 have already been initialized and enabled
// The Data/Command pin must be valid when the eighth bit is
// sent.  The eUSCI module has no hardware FIFOs.
// 1) Wait for transmitter to be empty (let previous frame finish)
// 2) Set DC for data (1)
// 3) Write data to TXBUF, starts SPI
// Note: takes 2us to output a byte
static void datawrite(uint8_t data){

    // Wait for transmitter to be empty (UCTXIFG)
    SPIA3_Wait4Tx();

    // DC = 1 for data
    DC = 1;

    // Send data using TXBUF
    SPIA3_WriteTxBuffer(data);
}


// Adjust this from 0xA0 (lighter) to 0xCF (darker) for your display.
// Start from 0xB1;
// try 0xB1 (for 3.3V red SparkFun),
// 0xB8 (for 3.3V blue SparkFun),
// 0xBF if your display is too dark, or 0x80 to 0xFF if experimenting
void Nokia5110_SetContrast(uint8_t contrast){

    // reset the LCD to a known state, RESET low
    RESET = 0;

    // delay minimum 100 ns
    for (int delay = 0; delay < 20; delay++);

    // hold RESET high
    RESET = 1;

    // chip active; horizontal addressing mode (V = 0);
    // use extended instruction set (H = 1)
    // set LCD Vop (contrast), which may require some tweaking:
    commandwrite(0x21);

    // try 0xB1 (for 3.3V red SparkFun),
    // 0xB8 (for 3.3V blue SparkFun),
    // 0xBF if your display is too dark, or 0x80 to 0xFF if experimenting
    commandwrite(contrast);

    commandwrite(0x04);     // set temp coefficient
    commandwrite(0x14);     // LCD bias mode 1:48: try 0x13 or 0x14
    commandwrite(0x20);     // we must send 0x20 before modifying the display control mode
    commandwrite(0x0C);     // set display control to normal mode: 0x0D for inverse
}


//********Nokia5110_Init*****************
// Initialize Nokia 5110 48x84 LCD by sending the proper
// commands to the PCD8544 driver.  One feature of the
// MSP432 is that its SSIs can get their baud clock from
// either the auxiliary clock (ACLK = REFOCLK/1 = 32,768 Hz
// see ClockSystem.c) or from the low-speed subsystem
// master clock (SMCLK <= 12 MHz see ClockSystem.c).  The
// SSI can further divide this clock signal by using the
// 16-bit Bit Rate Control prescaler Register, UCAxBRW.
// Inputs: none
// Outputs: none
// Assumes: low-speed subsystem master clock 12 MHz
void Nokia5110_Init(void) {

    // Initialize SPI A3
    SPIA3_Init();

    // configure P9.3 and P9.6 as GPIO (Reset and D/C pins)
    P9->SEL0 &= ~0x48;
    P9->SEL1 &= ~0x48;

    // make P9.3 and P9.6 out (Reset and D/C pins)
    P9->DIR |= 0x48;

    uint8_t const initial_constrat = 0x85;
    Nokia5110_SetContrast(initial_constrat);

}


//********Nokia5110_OutChar*****************
// Print a character to the Nokia 5110 48x84 LCD.  The
// character will be printed at the current cursor position,
// the cursor will automatically be updated, and it will
// wrap to the next row or back to the top if necessary.
// One blank column of pixels will be printed on either side
// of the character for readability.  Since characters are 8
// pixels tall and 5 pixels wide, 12 characters fit per row,
// and there are six rows.
// Inputs: data  character to print
// Outputs: none
// Assumes: LCD is in default horizontal addressing mode (V = 0)
// Note: takes 14us to output a character
void Nokia5110_OutChar(char data) {

    datawrite(0x00);        // blank vertical line padding
    for(int i = 0; i < 5; i = i+1){
        datawrite(ASCII[data - 0x20][i]);
    }
    datawrite(0x00);        // blank vertical line padding
}


//********Nokia5110_OutString*****************
// Print a string of characters to the Nokia 5110 48x84 LCD.
// Inputs: ptr pointer to NULL-terminated ASCII string
// Outputs: none
// Assumes: LCD is in default horizontal addressing mode (V = 0)
void Nokia5110_OutString(const char* ptr){

    // You write this as part of Lab 5
    // You must use Nokia5110_OutChar

}


#define STR_NUM_LENGTH 12   // To store a string for 32-bit signed and unsigned integers.
static char Buffer[STR_NUM_LENGTH];

//******** Nokia_Num2String *****************
// This is a static (private and internal) helper function.
// Converts a number to a fixed-length string and store it
// in Buffer defined above.
// Input:
// n: a number to convert into a string.
//   It must be an unsigned integer: uint8_t, uint16_t, uint32_t, or unsigned int.
// Output: number of digits in the string.
//
// Examples:
// If the input is 24860, Buffer becomes "06842xxxxx" and it returns 5 (# of digits).
//             +---+---+---+---+---+---+---+---+---+---+
//  Buffer --> |'0'|'6'|'8'|'4'|'2'| x | x | x | x | x |
//             +---+---+---+---+---+---+---+---+---+---+
// If the input is 4860, the output will be "0684xxxxxx" and it returns 4  (# of digits).
// If the input is 860, the output will be "068xxxxxxx" and it returns 3  (# of digits).
// where x denotes a garbage value previously stored in the array.
static int Nokia_Num2String(uint32_t n) {

    int count = 0;
    do {
        Buffer[count++] = (n%10) + '0';
        n = n/10;
    } while (n);

    return count;
}


void Nokia5110_OutUDec(uint32_t n, int min_length){
    // Write this as part of Lab 5

    // Convert the number into a reversed string.
    int count = Nokia_Num2String(n);
}


void Nokia5110_OutSDec(int32_t n, int min_length){
    // Write this as part of Lab 5

    // assign the magnitude of n to x
    // Ensure the magnitude of -2147483648(0x80000000) is 2147483648(0x80000000).
    // You are not allowed to use the built-in abs() function.
    uint32_t x = 0;

    // Convert the number into a reversed string.
    int count = Nokia_Num2String(x);

}


//********HexSingle_Helper*****************
// Helper function to display a single hex digit.
// Prints one character between 0 and F
// Inputs: n unsigned number to print.
//   n will be bit masked: n = n & 0x0F;
// Outputs: none
static void HexSingle_Helper(uint8_t n){
    n = n & 0x0F;
    if(n > 9) {
        Nokia5110_OutChar('A'+n-10);
    } else {
        Nokia5110_OutChar(n+'0');        // ones digit
    }
}

//********Nokia5110_Out8Hex*****************
// Output two hex digits to the Nokia 5110 LCD.
// Prints 4 characters with leading 0x
// Inputs: n unsigned number 0-255 to print
// Outputs: none
void Nokia5110_OutU8Hex(uint8_t n) {
    Nokia5110_OutString("0x");
    HexSingle_Helper(n/16);            // 16s digit
    HexSingle_Helper(n);               // ones digit
}


//********Nokia5110_Out8Bin*****************
// Output 8 bit number the Nokia 5110 LCD.
// Prints 8 characters with leading b
// Inputs: n unsigned number 0-255 to print
// Outputs: none
void Nokia5110_Out8Bin(uint8_t n) {
    Nokia5110_OutChar('b');
    for(int i = 7; i >= 0; i--) {
        Nokia5110_OutChar('0' + ((n>>i) & 0x01));
    }
}



// ==========================================================
//
//               DO NOT MODIFY ANYTHING BELOW
//
// ==========================================================


//********Nokia5110_SetCursor2*****************
// Move the cursor to the desired row and column position.
// The next character will be printed here.
// row = 1 is the top row and row = 6 is the bottom row
// col = 1 is the left most column and col = 12 is the right most column.
// Inputs: row row position of the cursor (1 <= row <= 12)
//         col column position of the cursor (1 <= col <= 12)
// Outputs: none
void Nokia5110_SetCursor2(uint8_t row, uint8_t col) {
    if((col > 12) || (row > 6)) {   // bad input
        return;                     // do nothing
    }

    // multiply (col-1) by 7 because each character is 7 columns wide
    // starting from 0.
    commandwrite(0x80|((col-1)*7));       // setting bit 7 updates col position
    commandwrite(0x40|(row-1));           // setting bit 6 updates row position
}


//********Nokia5110_SetCursor*****************
// Move the cursor to the desired X- and Y-position.  The
// next character will be printed here.  X=0 is the leftmost
// column.  Y=0 is the top row.
// Inputs: newX  new X-position of the cursor (0<=newX<=11)
//         newY  new Y-position of the cursor (0<=newY<=5)
// Outputs: none
__attribute__((deprecated))
void Nokia5110_SetCursor(uint8_t newX, uint8_t newY){
    if((newX > 11) || (newY > 5)){        // bad input
        return;                           // do nothing
    }
    // multiply newX by 7 because each character is 7 columns wide
    commandwrite(0x80|(newX*7));       // setting bit 7 updates X-position
    commandwrite(0x40|newY);           // setting bit 6 updates Y-position
}


//********Nokia5110_Clear*****************
// Clear the LCD by writing zeros to the entire screen and
// reset the cursor to (0,0) (top left corner of screen).
// Inputs: none
// Outputs: none
void Nokia5110_Clear(void){
    int i;
    for(i=0; i<(MAX_X*MAX_Y/8); i=i+1){
        datawrite(0x00);
    }

    Nokia5110_SetCursor2(1, 1);
}


//********Nokia5110_DrawFullImage*****************
// Fill the whole screen by drawing a 48x84 bitmap image.
// Inputs: ptr  pointer to 504 byte bitmap
// Outputs: none
// Assumes: LCD is in default horizontal addressing mode (V = 0)
void Nokia5110_DrawFullImage(const uint8_t *ptr){
    int i;
    Nokia5110_SetCursor2(1, 1);
    for(i=0; i<(MAX_X*MAX_Y/8); i=i+1){
        datawrite(ptr[i]);
    }
}


uint8_t Screen[SCREENW*SCREENH/8]; // buffer stores the next image to be printed on the screen

//********Nokia5110_PrintBMP*****************
// Bitmaps defined above were created for the LM3S1968 or
// LM3S8962's 4-bit grayscale OLED display.  They also
// still contain their header data and may contain padding
// to preserve 4-byte alignment.  This function takes a
// bitmap in the previously described format and puts its
// image data in the proper location in the buffer so the
// image will appear on the screen after the next call to
//   Nokia5110_DisplayBuffer();
// The interface and operation of this process is modeled
// after RIT128x96x4_BMP(x, y, image);
// Inputs: xpos      horizontal position of bottom left corner of image, columns from the left edge
//                     must be less than 84
//                     0 is on the left; 82 is near the right
//         ypos      vertical position of bottom left corner of image, rows from the top edge
//                     must be less than 48
//                     2 is near the top; 47 is at the bottom
//         bmp       pointer to a 16 color BMP image
//         threshold grayscale colors above this number make corresponding pixel 'on'
//                     0 to 14
//                     0 is fine for ships, explosions, projectiles, and bunkers
// Outputs: none
void Nokia5110_PrintBMP(uint8_t xpos, uint8_t ypos, const uint8_t *bmp, uint8_t threshold) {

    int32_t width = bmp[18], height = bmp[22];
    uint8_t mask;

    // check for clipping
    if ((height <= 0) ||                // bitmap is unexpectedly encoded in top-to-bottom pixel order
        ((width%2) != 0) ||             // must be even number of columns
        ((xpos + width) > SCREENW) ||   // right side cut off
        (ypos < (height - 1)) ||        // top cut off
        (ypos > SCREENH)) {             // bottom cut off
        return;
    }

    if(threshold > 14)  {
        threshold = 14;                 // only full 'on' turns pixel on
    }

    // bitmaps are encoded backwards, so start at the bottom left corner of the image
    uint16_t screeny = ypos/8;
    uint16_t screenx = xpos + SCREENW*screeny;
    mask = ypos%8;                // row 0 to 7
    mask = 0x01<<mask;            // now stores a mask 0x01 to 0x80

    uint32_t j = bmp[10];                  // byte 10 contains the offset where image data can be found
    for(uint32_t i=1; i<=(width*height/2); i=i+1) {

        // the left pixel is in the upper 4 bits
        if(((bmp[j]>>4)&0xF) > threshold){
          Screen[screenx] |= mask;
        } else{
          Screen[screenx] &= ~mask;
        }

        screenx = screenx + 1;

        // the right pixel is in the lower 4 bits
        if((bmp[j]&0xF) > threshold){
          Screen[screenx] |= mask;
        } else{
          Screen[screenx] &= ~mask;
        }

        screenx = screenx + 1;

        j = j + 1;
        if((i%(width/2)) == 0){     // at the end of a row
            if(mask > 0x01){
            mask = mask>>1;
            } else{
            mask = 0x80;
            screeny = screeny - 1;
            }
            screenx = xpos + SCREENW*screeny;
            // bitmaps are 32-bit word aligned
            switch((width/2)%4){      // skip any padding
                case 0: j = j + 0; break;
                case 1: j = j + 3; break;
                case 2: j = j + 2; break;
                case 3: j = j + 1; break;
            }
        }
    }
}


//********Nokia5110_ClearBuffer*****************
// There is a buffer in RAM that holds one screen.
// This routine clears that buffer.
// Inputs: none
// Outputs: none
void Nokia5110_ClearBuffer(void){int i;
    for(i=0; i<SCREENW*SCREENH/8; i=i+1){
        Screen[i] = 0;              // clear buffer
    }
}


//********Nokia5110_DisplayBuffer*****************
// Fill the whole screen by drawing a 48x84 screen image
// from the RAM buffer.
// Inputs: none
// Outputs: none
// Assumes: LCD is in default horizontal addressing mode (V = 0)
void Nokia5110_DisplayBuffer(void){
    Nokia5110_DrawFullImage(Screen);
}


const unsigned char Masks[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
//------------Nokia5110_ClrPxl------------
// Clear the internal screen buffer pixel at (i, j),
// turning it off.
// Input: i  the row index  (0 to 47 in this case),    y-coordinate
//        j  the column index  (0 to 83 in this case), x-coordinate
// Output: none
void Nokia5110_ClrPxl(uint32_t i, uint32_t j){
    Screen[84*(i>>3) + j] &= ~Masks[i&0x07];
}


//------------Nokia5110_SetPxl------------
// Set the internal screen buffer pixel at (i, j),
// turning it on.
// Input: i  the row index  (0 to 47 in this case),    y-coordinate
//        j  the column index  (0 to 83 in this case), x-coordinate
// Output: none
void Nokia5110_SetPxl(uint32_t i, uint32_t j){
    Screen[84*(i>>3) + j] |= Masks[i&0x07];
}
